.ll 60n
.TH AFP 8 "DECEMBER 2010" PSU "User Manuals"
.SH NAME 
afp-dev \- afp filter development guide
.SH OVERVIEW
This guide aims to provide a brief walk through of the filter
creation process.

Every filter has a type: 
.BR Source , Link ", or " Sink
which indicates whether they pull audio into the pipeline, 
process audio data, or dispatch audio data elsewhere.

Filters may be developed as stand alone executables in any language.
They may be run using the appropriate built in 'exec' filter, and should 
understand the format outlined in
.BR afp-fmt (5).
The rest of this document does not apply to these.

Filters may also be developed in Go and built into 
.BR afp (1)
as follows.

.SH THE FILTER INTERFACE
.PP
.RS 0
type Filter interface {
.RS 0
	GetType() int
.RS 0
	Init(*afp.Context, []string) os.Error
.RS 0
	Start()
.RS 0
	Stop() os.Error
.RS 0
}

Every filter must import the "afp" package,
and implement the afp.Filter interface.  The
purpose of each method required is as follows:

.SS GetType() int
Should return one of 
.BR afp.PIPE_SOURCE", "afp.PIPE_LINK", or "afp.PIPE_SINK
depending on the purpose of the filter.

.SS Init(*afp.Context, []string) os.Error
Will be passed a pointer to a context object as outlined below,
and a slice of strings holding the arguments passed to this filter.
No reads/writes on the channels held in the 
.B Context
object should occur in Init.
Any error returned from Init will cause 
.BR afp (1)
to exit immediately with the error's message

.SS Start()
This method will hold or call all audio processing routines.
Its behavior will vary depending on the type of the filter,
but should look something like:
.PP
.RS 0
header := <-context.HeaderSource //Except in Sources
.RS 0
//Modify header if needed
.RS 0
context.HeaderSink <- modifiedHeader //Except in Sinks
.RS 0

.RS 0
for inputAvailable {
.RS 0
		frame := <context.Source
.RS 0
		//Process
.RS 0
		context.Sink <- frame
.RS 0
}
.RS 0
close(context.Sink)

Note that frames should not be modified after being sent, if 
access to multiple frames is necessary, they should be explicitly 
buffered and sent only when they've passed out of the window.

Any panics thrown in start will be caught by the pipeline manager
and cause an orderly shutdown of the pipe.  If a goroutine invoked
in 
.B Start()
panics, it will not be caught, and may cause file corruption.  Therefor
when possible goroutines should send errors to the calling Start(), which
can panic on their behalf.

To avoid spinning, all channel reads and writes in Start should be blocking.

.SS Stop() os.Error
This method will be called if some filter causes an unplanned shutdown of the 
pipeline.  It should end processing in a sane way if possible, and return any
errors encountered while doing so.  Errors will be displayed to the user as part 
of the crash dump.

.SH THE CONTEXT OBJECT
.PP
.RS 0
type Context struct {
.RS 0
	HeaderSource <-chan StreamHeader
.RS 0
	HeaderSink   chan<- StreamHeader
.RS 0
	Source       <-chan [][]float32
.RS 0
	Sink         chan<- [][]float32
.RS 0

.RS 0
	Verbose   bool
.RS 0
	Err, Info *log.Logger
.RS 0
}

Every thread will be passed a
.B *afp.Context 
during initialization, it should store this locally.  
This object holds the channels used to communicate with other 
pieces of the pipeline, as will as logging utilities.

Generally, messages should be written to the Info logger only if 
.B Verbose
is true.  Any non-fatal errors should be reported using the Err
logger. Fatal errors may also write to Err, but should also 
cause a panic as outlined above.

.SH THE STREAM HEADER
.PP
.RS 0
type StreamHeader struct {
.RS 0
	Version       int8
.RS 0
	Channels      int8
.RS 0
	SampleSize    int8
.RS 0
	SampleRate    int32
.RS 0
	FrameSize     int32
.RS 0
	ContentLength int64
.RS 0
}

The StreamHeader holds the header information as outlined in 
.BR afp-fmt (5)

.SS Version
The header version. Future header versions may be incompatible.

.SS Channels
The number of channels of audio data, usually 1 or 2, but may be
as large as 127.

.SS SampleSize
The number of bits used to store each channel sample. Currently always 32.

.SS FrameSize
The number of time slices per frame.

.SS Content Length
The length in bytes of the content which follows. If the value is unknown
this field will be 0.		

.SH AUTHORS
Aaron Devore <adevore at cs.pdx.edu>
.br
K. Jon Harker <kjharke at cs.pdx.edu>
.br
Cory Kolbeck <ckolbeck at cs.pdx.edu>
.br
Eric Oconnel <eoc at cs.pdx.edu>
.SH "SEE ALSO"
.BR afp (3),
.BR afp-fmt (5)
